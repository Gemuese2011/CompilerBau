Grammar:

Rule 0     S' -> expression
Rule 1     expression -> VARIABLE_NAME IS ARRAY OF VAR_TYPE WITH L_SQUARE_BRACKETS value_list R_SQUARE_BRACKETS
Rule 2     expression -> CAST VARIABLE_NAME TO VAR_TYPE
Rule 3     expression -> VARIABLE_NAME ASSIGN expr
Rule 4     expression -> PRINT LPAREN statement RPAREN
Rule 5     expression -> COMMENT
Rule 6     expression -> declaration_list
Rule 7     declaration_list -> declaration declaration_list
Rule 8     declaration_list -> declaration
Rule 9     declaration -> CONSTANTS_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN variable_value
Rule 10    declaration -> CONSTANTS_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN variable_value
Rule 11    declaration -> VARIABLE_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN variable_value
Rule 12    declaration -> VARIABLE_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN variable_value
Rule 13    statement -> WHILE bool_op DO statement
Rule 14    statement -> IF bool_op THEN statement ELSE statement
Rule 15    statement -> IF bool_op THEN statement
Rule 16    statement -> bool_op
Rule 17    statement -> expr
Rule 18    statement -> VARIABLE_NAME L_SQUARE_BRACKETS variable_value R_SQUARE_BRACKETS
Rule 19    statement -> VARIABLE_NAME
Rule 20    statement -> VARIABLES
Rule 21    statement -> NAMES
Rule 22    bool_op -> expr LE expr
Rule 23    bool_op -> expr GE expr
Rule 24    bool_op -> expr LT expr
Rule 25    bool_op -> expr GT expr
Rule 26    bool_op -> expr NEQ expr
Rule 27    bool_op -> expr EQ expr
Rule 28    expr -> VARIABLE_NAME
Rule 29    expr -> variable_value
Rule 30    expr -> LPAREN expr RPAREN
Rule 31    expr -> - expr  [precedence=right, level=3]
Rule 32    expr -> expr / expr  [precedence=left, level=2]
Rule 33    expr -> expr * expr  [precedence=left, level=2]
Rule 34    expr -> expr - expr  [precedence=left, level=1]
Rule 35    expr -> expr + expr  [precedence=left, level=1]
Rule 36    value_list -> variable_value
Rule 37    value_list -> variable_value COMMA value_list
Rule 38    variable_value -> STRING_VALUE
Rule 39    variable_value -> FLOAT_VALUE
Rule 40    variable_value -> INTEGER_VALUE

Terminals, with rules where they appear:

*                    : 33
+                    : 35
-                    : 31 34
/                    : 32
ARRAY                : 1
ASSIGN               : 3 9 10 11 12
CAST                 : 2
COLON                : 9 11
COMMA                : 37
COMMENT              : 5
CONSTANTS_PREFIX     : 9 10
DO                   : 13
ELSE                 : 14
EQ                   : 27
FLOAT_VALUE          : 39
GE                   : 23
GT                   : 25
IF                   : 14 15
INTEGER_VALUE        : 40
IS                   : 1 10 12
LE                   : 22
LPAREN               : 4 30
LT                   : 24
L_SQUARE_BRACKETS    : 1 18
NAMES                : 21
NEQ                  : 26
OF                   : 1
PRINT                : 4
RPAREN               : 4 30
R_SQUARE_BRACKETS    : 1 18
STRING_VALUE         : 38
THEN                 : 14 15
TO                   : 2
VARIABLES            : 20
VARIABLE_NAME        : 1 2 3 9 10 11 12 18 19 28
VARIABLE_PREFIX      : 11 12
VAR_TYPE             : 1 2 9 10 11 12
WHILE                : 13
WITH                 : 1
error                : 

Nonterminals, with rules where they appear:

bool_op              : 13 14 15 16
declaration          : 7 8
declaration_list     : 6 7
expr                 : 3 17 22 22 23 23 24 24 25 25 26 26 27 27 30 31 32 32 33 33 34 34 35 35
expression           : 0
statement            : 4 13 14 14 15
value_list           : 1 37
variable_value       : 9 10 11 12 18 29 36 37


state 0

    (0) S' -> . expression
    (1) expression -> . VARIABLE_NAME IS ARRAY OF VAR_TYPE WITH L_SQUARE_BRACKETS value_list R_SQUARE_BRACKETS
    (2) expression -> . CAST VARIABLE_NAME TO VAR_TYPE
    (3) expression -> . VARIABLE_NAME ASSIGN expr
    (4) expression -> . PRINT LPAREN statement RPAREN
    (5) expression -> . COMMENT
    (6) expression -> . declaration_list
    (7) declaration_list -> . declaration declaration_list
    (8) declaration_list -> . declaration
    (9) declaration -> . CONSTANTS_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN variable_value
    (10) declaration -> . CONSTANTS_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN variable_value
    (11) declaration -> . VARIABLE_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN variable_value
    (12) declaration -> . VARIABLE_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN variable_value
    VARIABLE_NAME   shift and go to state 2
    CAST            shift and go to state 3
    PRINT           shift and go to state 4
    COMMENT         shift and go to state 5
    CONSTANTS_PREFIX shift and go to state 8
    VARIABLE_PREFIX shift and go to state 9

    expression                     shift and go to state 1
    declaration_list               shift and go to state 6
    declaration                    shift and go to state 7

state 1

    (0) S' -> expression .


state 2

    (1) expression -> VARIABLE_NAME . IS ARRAY OF VAR_TYPE WITH L_SQUARE_BRACKETS value_list R_SQUARE_BRACKETS
    (3) expression -> VARIABLE_NAME . ASSIGN expr
    IS              shift and go to state 10
    ASSIGN          shift and go to state 11


state 3

    (2) expression -> CAST . VARIABLE_NAME TO VAR_TYPE
    VARIABLE_NAME   shift and go to state 12


state 4

    (4) expression -> PRINT . LPAREN statement RPAREN
    LPAREN          shift and go to state 13


state 5

    (5) expression -> COMMENT .
    $end            reduce using rule 5 (expression -> COMMENT .)


state 6

    (6) expression -> declaration_list .
    $end            reduce using rule 6 (expression -> declaration_list .)


state 7

    (7) declaration_list -> declaration . declaration_list
    (8) declaration_list -> declaration .
    (7) declaration_list -> . declaration declaration_list
    (8) declaration_list -> . declaration
    (9) declaration -> . CONSTANTS_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN variable_value
    (10) declaration -> . CONSTANTS_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN variable_value
    (11) declaration -> . VARIABLE_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN variable_value
    (12) declaration -> . VARIABLE_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN variable_value
    $end            reduce using rule 8 (declaration_list -> declaration .)
    CONSTANTS_PREFIX shift and go to state 8
    VARIABLE_PREFIX shift and go to state 9

    declaration                    shift and go to state 7
    declaration_list               shift and go to state 14

state 8

    (9) declaration -> CONSTANTS_PREFIX . VARIABLE_NAME COLON VAR_TYPE ASSIGN variable_value
    (10) declaration -> CONSTANTS_PREFIX . VARIABLE_NAME IS VAR_TYPE ASSIGN variable_value
    VARIABLE_NAME   shift and go to state 15


state 9

    (11) declaration -> VARIABLE_PREFIX . VARIABLE_NAME COLON VAR_TYPE ASSIGN variable_value
    (12) declaration -> VARIABLE_PREFIX . VARIABLE_NAME IS VAR_TYPE ASSIGN variable_value
    VARIABLE_NAME   shift and go to state 16


state 10

    (1) expression -> VARIABLE_NAME IS . ARRAY OF VAR_TYPE WITH L_SQUARE_BRACKETS value_list R_SQUARE_BRACKETS
    ARRAY           shift and go to state 17


state 11

    (3) expression -> VARIABLE_NAME ASSIGN . expr
    (28) expr -> . VARIABLE_NAME
    (29) expr -> . variable_value
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . - expr
    (32) expr -> . expr / expr
    (33) expr -> . expr * expr
    (34) expr -> . expr - expr
    (35) expr -> . expr + expr
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    VARIABLE_NAME   shift and go to state 18
    LPAREN          shift and go to state 21
    -               shift and go to state 22
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    expr                           shift and go to state 19
    variable_value                 shift and go to state 20

state 12

    (2) expression -> CAST VARIABLE_NAME . TO VAR_TYPE
    TO              shift and go to state 26


state 13

    (4) expression -> PRINT LPAREN . statement RPAREN
    (13) statement -> . WHILE bool_op DO statement
    (14) statement -> . IF bool_op THEN statement ELSE statement
    (15) statement -> . IF bool_op THEN statement
    (16) statement -> . bool_op
    (17) statement -> . expr
    (18) statement -> . VARIABLE_NAME L_SQUARE_BRACKETS variable_value R_SQUARE_BRACKETS
    (19) statement -> . VARIABLE_NAME
    (20) statement -> . VARIABLES
    (21) statement -> . NAMES
    (22) bool_op -> . expr LE expr
    (23) bool_op -> . expr GE expr
    (24) bool_op -> . expr LT expr
    (25) bool_op -> . expr GT expr
    (26) bool_op -> . expr NEQ expr
    (27) bool_op -> . expr EQ expr
    (28) expr -> . VARIABLE_NAME
    (29) expr -> . variable_value
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . - expr
    (32) expr -> . expr / expr
    (33) expr -> . expr * expr
    (34) expr -> . expr - expr
    (35) expr -> . expr + expr
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    WHILE           shift and go to state 28
    IF              shift and go to state 30
    VARIABLE_NAME   shift and go to state 32
    VARIABLES       shift and go to state 33
    NAMES           shift and go to state 34
    LPAREN          shift and go to state 21
    -               shift and go to state 22
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    statement                      shift and go to state 27
    bool_op                        shift and go to state 29
    expr                           shift and go to state 31
    variable_value                 shift and go to state 20

state 14

    (7) declaration_list -> declaration declaration_list .
    $end            reduce using rule 7 (declaration_list -> declaration declaration_list .)


state 15

    (9) declaration -> CONSTANTS_PREFIX VARIABLE_NAME . COLON VAR_TYPE ASSIGN variable_value
    (10) declaration -> CONSTANTS_PREFIX VARIABLE_NAME . IS VAR_TYPE ASSIGN variable_value
    COLON           shift and go to state 35
    IS              shift and go to state 36


state 16

    (11) declaration -> VARIABLE_PREFIX VARIABLE_NAME . COLON VAR_TYPE ASSIGN variable_value
    (12) declaration -> VARIABLE_PREFIX VARIABLE_NAME . IS VAR_TYPE ASSIGN variable_value
    COLON           shift and go to state 37
    IS              shift and go to state 38


state 17

    (1) expression -> VARIABLE_NAME IS ARRAY . OF VAR_TYPE WITH L_SQUARE_BRACKETS value_list R_SQUARE_BRACKETS
    OF              shift and go to state 39


state 18

    (28) expr -> VARIABLE_NAME .
    /               reduce using rule 28 (expr -> VARIABLE_NAME .)
    *               reduce using rule 28 (expr -> VARIABLE_NAME .)
    -               reduce using rule 28 (expr -> VARIABLE_NAME .)
    +               reduce using rule 28 (expr -> VARIABLE_NAME .)
    $end            reduce using rule 28 (expr -> VARIABLE_NAME .)
    RPAREN          reduce using rule 28 (expr -> VARIABLE_NAME .)
    LE              reduce using rule 28 (expr -> VARIABLE_NAME .)
    GE              reduce using rule 28 (expr -> VARIABLE_NAME .)
    LT              reduce using rule 28 (expr -> VARIABLE_NAME .)
    GT              reduce using rule 28 (expr -> VARIABLE_NAME .)
    NEQ             reduce using rule 28 (expr -> VARIABLE_NAME .)
    EQ              reduce using rule 28 (expr -> VARIABLE_NAME .)
    DO              reduce using rule 28 (expr -> VARIABLE_NAME .)
    THEN            reduce using rule 28 (expr -> VARIABLE_NAME .)
    ELSE            reduce using rule 28 (expr -> VARIABLE_NAME .)


state 19

    (3) expression -> VARIABLE_NAME ASSIGN expr .
    (32) expr -> expr . / expr
    (33) expr -> expr . * expr
    (34) expr -> expr . - expr
    (35) expr -> expr . + expr
    $end            reduce using rule 3 (expression -> VARIABLE_NAME ASSIGN expr .)
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43


state 20

    (29) expr -> variable_value .
    /               reduce using rule 29 (expr -> variable_value .)
    *               reduce using rule 29 (expr -> variable_value .)
    -               reduce using rule 29 (expr -> variable_value .)
    +               reduce using rule 29 (expr -> variable_value .)
    $end            reduce using rule 29 (expr -> variable_value .)
    LE              reduce using rule 29 (expr -> variable_value .)
    GE              reduce using rule 29 (expr -> variable_value .)
    LT              reduce using rule 29 (expr -> variable_value .)
    GT              reduce using rule 29 (expr -> variable_value .)
    NEQ             reduce using rule 29 (expr -> variable_value .)
    EQ              reduce using rule 29 (expr -> variable_value .)
    RPAREN          reduce using rule 29 (expr -> variable_value .)
    DO              reduce using rule 29 (expr -> variable_value .)
    THEN            reduce using rule 29 (expr -> variable_value .)
    ELSE            reduce using rule 29 (expr -> variable_value .)


state 21

    (30) expr -> LPAREN . expr RPAREN
    (28) expr -> . VARIABLE_NAME
    (29) expr -> . variable_value
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . - expr
    (32) expr -> . expr / expr
    (33) expr -> . expr * expr
    (34) expr -> . expr - expr
    (35) expr -> . expr + expr
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    VARIABLE_NAME   shift and go to state 18
    LPAREN          shift and go to state 21
    -               shift and go to state 22
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    expr                           shift and go to state 44
    variable_value                 shift and go to state 20

state 22

    (31) expr -> - . expr
    (28) expr -> . VARIABLE_NAME
    (29) expr -> . variable_value
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . - expr
    (32) expr -> . expr / expr
    (33) expr -> . expr * expr
    (34) expr -> . expr - expr
    (35) expr -> . expr + expr
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    VARIABLE_NAME   shift and go to state 18
    LPAREN          shift and go to state 21
    -               shift and go to state 22
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    expr                           shift and go to state 45
    variable_value                 shift and go to state 20

state 23

    (38) variable_value -> STRING_VALUE .
    /               reduce using rule 38 (variable_value -> STRING_VALUE .)
    *               reduce using rule 38 (variable_value -> STRING_VALUE .)
    -               reduce using rule 38 (variable_value -> STRING_VALUE .)
    +               reduce using rule 38 (variable_value -> STRING_VALUE .)
    $end            reduce using rule 38 (variable_value -> STRING_VALUE .)
    LE              reduce using rule 38 (variable_value -> STRING_VALUE .)
    GE              reduce using rule 38 (variable_value -> STRING_VALUE .)
    LT              reduce using rule 38 (variable_value -> STRING_VALUE .)
    GT              reduce using rule 38 (variable_value -> STRING_VALUE .)
    NEQ             reduce using rule 38 (variable_value -> STRING_VALUE .)
    EQ              reduce using rule 38 (variable_value -> STRING_VALUE .)
    RPAREN          reduce using rule 38 (variable_value -> STRING_VALUE .)
    DO              reduce using rule 38 (variable_value -> STRING_VALUE .)
    THEN            reduce using rule 38 (variable_value -> STRING_VALUE .)
    ELSE            reduce using rule 38 (variable_value -> STRING_VALUE .)
    R_SQUARE_BRACKETS reduce using rule 38 (variable_value -> STRING_VALUE .)
    CONSTANTS_PREFIX reduce using rule 38 (variable_value -> STRING_VALUE .)
    VARIABLE_PREFIX reduce using rule 38 (variable_value -> STRING_VALUE .)
    COMMA           reduce using rule 38 (variable_value -> STRING_VALUE .)


state 24

    (39) variable_value -> FLOAT_VALUE .
    /               reduce using rule 39 (variable_value -> FLOAT_VALUE .)
    *               reduce using rule 39 (variable_value -> FLOAT_VALUE .)
    -               reduce using rule 39 (variable_value -> FLOAT_VALUE .)
    +               reduce using rule 39 (variable_value -> FLOAT_VALUE .)
    $end            reduce using rule 39 (variable_value -> FLOAT_VALUE .)
    LE              reduce using rule 39 (variable_value -> FLOAT_VALUE .)
    GE              reduce using rule 39 (variable_value -> FLOAT_VALUE .)
    LT              reduce using rule 39 (variable_value -> FLOAT_VALUE .)
    GT              reduce using rule 39 (variable_value -> FLOAT_VALUE .)
    NEQ             reduce using rule 39 (variable_value -> FLOAT_VALUE .)
    EQ              reduce using rule 39 (variable_value -> FLOAT_VALUE .)
    RPAREN          reduce using rule 39 (variable_value -> FLOAT_VALUE .)
    DO              reduce using rule 39 (variable_value -> FLOAT_VALUE .)
    THEN            reduce using rule 39 (variable_value -> FLOAT_VALUE .)
    ELSE            reduce using rule 39 (variable_value -> FLOAT_VALUE .)
    R_SQUARE_BRACKETS reduce using rule 39 (variable_value -> FLOAT_VALUE .)
    CONSTANTS_PREFIX reduce using rule 39 (variable_value -> FLOAT_VALUE .)
    VARIABLE_PREFIX reduce using rule 39 (variable_value -> FLOAT_VALUE .)
    COMMA           reduce using rule 39 (variable_value -> FLOAT_VALUE .)


state 25

    (40) variable_value -> INTEGER_VALUE .
    /               reduce using rule 40 (variable_value -> INTEGER_VALUE .)
    *               reduce using rule 40 (variable_value -> INTEGER_VALUE .)
    -               reduce using rule 40 (variable_value -> INTEGER_VALUE .)
    +               reduce using rule 40 (variable_value -> INTEGER_VALUE .)
    $end            reduce using rule 40 (variable_value -> INTEGER_VALUE .)
    LE              reduce using rule 40 (variable_value -> INTEGER_VALUE .)
    GE              reduce using rule 40 (variable_value -> INTEGER_VALUE .)
    LT              reduce using rule 40 (variable_value -> INTEGER_VALUE .)
    GT              reduce using rule 40 (variable_value -> INTEGER_VALUE .)
    NEQ             reduce using rule 40 (variable_value -> INTEGER_VALUE .)
    EQ              reduce using rule 40 (variable_value -> INTEGER_VALUE .)
    RPAREN          reduce using rule 40 (variable_value -> INTEGER_VALUE .)
    DO              reduce using rule 40 (variable_value -> INTEGER_VALUE .)
    THEN            reduce using rule 40 (variable_value -> INTEGER_VALUE .)
    ELSE            reduce using rule 40 (variable_value -> INTEGER_VALUE .)
    R_SQUARE_BRACKETS reduce using rule 40 (variable_value -> INTEGER_VALUE .)
    CONSTANTS_PREFIX reduce using rule 40 (variable_value -> INTEGER_VALUE .)
    VARIABLE_PREFIX reduce using rule 40 (variable_value -> INTEGER_VALUE .)
    COMMA           reduce using rule 40 (variable_value -> INTEGER_VALUE .)


state 26

    (2) expression -> CAST VARIABLE_NAME TO . VAR_TYPE
    VAR_TYPE        shift and go to state 46


state 27

    (4) expression -> PRINT LPAREN statement . RPAREN
    RPAREN          shift and go to state 47


state 28

    (13) statement -> WHILE . bool_op DO statement
    (22) bool_op -> . expr LE expr
    (23) bool_op -> . expr GE expr
    (24) bool_op -> . expr LT expr
    (25) bool_op -> . expr GT expr
    (26) bool_op -> . expr NEQ expr
    (27) bool_op -> . expr EQ expr
    (28) expr -> . VARIABLE_NAME
    (29) expr -> . variable_value
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . - expr
    (32) expr -> . expr / expr
    (33) expr -> . expr * expr
    (34) expr -> . expr - expr
    (35) expr -> . expr + expr
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    VARIABLE_NAME   shift and go to state 18
    LPAREN          shift and go to state 21
    -               shift and go to state 22
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    bool_op                        shift and go to state 48
    expr                           shift and go to state 49
    variable_value                 shift and go to state 20

state 29

    (16) statement -> bool_op .
    RPAREN          reduce using rule 16 (statement -> bool_op .)
    ELSE            reduce using rule 16 (statement -> bool_op .)


state 30

    (14) statement -> IF . bool_op THEN statement ELSE statement
    (15) statement -> IF . bool_op THEN statement
    (22) bool_op -> . expr LE expr
    (23) bool_op -> . expr GE expr
    (24) bool_op -> . expr LT expr
    (25) bool_op -> . expr GT expr
    (26) bool_op -> . expr NEQ expr
    (27) bool_op -> . expr EQ expr
    (28) expr -> . VARIABLE_NAME
    (29) expr -> . variable_value
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . - expr
    (32) expr -> . expr / expr
    (33) expr -> . expr * expr
    (34) expr -> . expr - expr
    (35) expr -> . expr + expr
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    VARIABLE_NAME   shift and go to state 18
    LPAREN          shift and go to state 21
    -               shift and go to state 22
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    bool_op                        shift and go to state 50
    expr                           shift and go to state 49
    variable_value                 shift and go to state 20

state 31

    (17) statement -> expr .
    (22) bool_op -> expr . LE expr
    (23) bool_op -> expr . GE expr
    (24) bool_op -> expr . LT expr
    (25) bool_op -> expr . GT expr
    (26) bool_op -> expr . NEQ expr
    (27) bool_op -> expr . EQ expr
    (32) expr -> expr . / expr
    (33) expr -> expr . * expr
    (34) expr -> expr . - expr
    (35) expr -> expr . + expr
    RPAREN          reduce using rule 17 (statement -> expr .)
    ELSE            reduce using rule 17 (statement -> expr .)
    LE              shift and go to state 51
    GE              shift and go to state 52
    LT              shift and go to state 53
    GT              shift and go to state 54
    NEQ             shift and go to state 55
    EQ              shift and go to state 56
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43


state 32

    (18) statement -> VARIABLE_NAME . L_SQUARE_BRACKETS variable_value R_SQUARE_BRACKETS
    (19) statement -> VARIABLE_NAME .
    (28) expr -> VARIABLE_NAME .
  ! reduce/reduce conflict for RPAREN resolved using rule 19 (statement -> VARIABLE_NAME .)
  ! reduce/reduce conflict for ELSE resolved using rule 19 (statement -> VARIABLE_NAME .)
    L_SQUARE_BRACKETS shift and go to state 57
    RPAREN          reduce using rule 19 (statement -> VARIABLE_NAME .)
    ELSE            reduce using rule 19 (statement -> VARIABLE_NAME .)
    LE              reduce using rule 28 (expr -> VARIABLE_NAME .)
    GE              reduce using rule 28 (expr -> VARIABLE_NAME .)
    LT              reduce using rule 28 (expr -> VARIABLE_NAME .)
    GT              reduce using rule 28 (expr -> VARIABLE_NAME .)
    NEQ             reduce using rule 28 (expr -> VARIABLE_NAME .)
    EQ              reduce using rule 28 (expr -> VARIABLE_NAME .)
    /               reduce using rule 28 (expr -> VARIABLE_NAME .)
    *               reduce using rule 28 (expr -> VARIABLE_NAME .)
    -               reduce using rule 28 (expr -> VARIABLE_NAME .)
    +               reduce using rule 28 (expr -> VARIABLE_NAME .)


state 33

    (20) statement -> VARIABLES .
    RPAREN          reduce using rule 20 (statement -> VARIABLES .)
    ELSE            reduce using rule 20 (statement -> VARIABLES .)


state 34

    (21) statement -> NAMES .
    RPAREN          reduce using rule 21 (statement -> NAMES .)
    ELSE            reduce using rule 21 (statement -> NAMES .)


state 35

    (9) declaration -> CONSTANTS_PREFIX VARIABLE_NAME COLON . VAR_TYPE ASSIGN variable_value
    VAR_TYPE        shift and go to state 58


state 36

    (10) declaration -> CONSTANTS_PREFIX VARIABLE_NAME IS . VAR_TYPE ASSIGN variable_value
    VAR_TYPE        shift and go to state 59


state 37

    (11) declaration -> VARIABLE_PREFIX VARIABLE_NAME COLON . VAR_TYPE ASSIGN variable_value
    VAR_TYPE        shift and go to state 60


state 38

    (12) declaration -> VARIABLE_PREFIX VARIABLE_NAME IS . VAR_TYPE ASSIGN variable_value
    VAR_TYPE        shift and go to state 61


state 39

    (1) expression -> VARIABLE_NAME IS ARRAY OF . VAR_TYPE WITH L_SQUARE_BRACKETS value_list R_SQUARE_BRACKETS
    VAR_TYPE        shift and go to state 62


state 40

    (32) expr -> expr / . expr
    (28) expr -> . VARIABLE_NAME
    (29) expr -> . variable_value
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . - expr
    (32) expr -> . expr / expr
    (33) expr -> . expr * expr
    (34) expr -> . expr - expr
    (35) expr -> . expr + expr
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    VARIABLE_NAME   shift and go to state 18
    LPAREN          shift and go to state 21
    -               shift and go to state 22
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    expr                           shift and go to state 63
    variable_value                 shift and go to state 20

state 41

    (33) expr -> expr * . expr
    (28) expr -> . VARIABLE_NAME
    (29) expr -> . variable_value
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . - expr
    (32) expr -> . expr / expr
    (33) expr -> . expr * expr
    (34) expr -> . expr - expr
    (35) expr -> . expr + expr
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    VARIABLE_NAME   shift and go to state 18
    LPAREN          shift and go to state 21
    -               shift and go to state 22
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    expr                           shift and go to state 64
    variable_value                 shift and go to state 20

state 42

    (34) expr -> expr - . expr
    (28) expr -> . VARIABLE_NAME
    (29) expr -> . variable_value
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . - expr
    (32) expr -> . expr / expr
    (33) expr -> . expr * expr
    (34) expr -> . expr - expr
    (35) expr -> . expr + expr
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    VARIABLE_NAME   shift and go to state 18
    LPAREN          shift and go to state 21
    -               shift and go to state 22
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    expr                           shift and go to state 65
    variable_value                 shift and go to state 20

state 43

    (35) expr -> expr + . expr
    (28) expr -> . VARIABLE_NAME
    (29) expr -> . variable_value
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . - expr
    (32) expr -> . expr / expr
    (33) expr -> . expr * expr
    (34) expr -> . expr - expr
    (35) expr -> . expr + expr
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    VARIABLE_NAME   shift and go to state 18
    LPAREN          shift and go to state 21
    -               shift and go to state 22
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    expr                           shift and go to state 66
    variable_value                 shift and go to state 20

state 44

    (30) expr -> LPAREN expr . RPAREN
    (32) expr -> expr . / expr
    (33) expr -> expr . * expr
    (34) expr -> expr . - expr
    (35) expr -> expr . + expr
    RPAREN          shift and go to state 67
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43


state 45

    (31) expr -> - expr .
    (32) expr -> expr . / expr
    (33) expr -> expr . * expr
    (34) expr -> expr . - expr
    (35) expr -> expr . + expr
    /               reduce using rule 31 (expr -> - expr .)
    *               reduce using rule 31 (expr -> - expr .)
    -               reduce using rule 31 (expr -> - expr .)
    +               reduce using rule 31 (expr -> - expr .)
    $end            reduce using rule 31 (expr -> - expr .)
    LE              reduce using rule 31 (expr -> - expr .)
    GE              reduce using rule 31 (expr -> - expr .)
    LT              reduce using rule 31 (expr -> - expr .)
    GT              reduce using rule 31 (expr -> - expr .)
    NEQ             reduce using rule 31 (expr -> - expr .)
    EQ              reduce using rule 31 (expr -> - expr .)
    RPAREN          reduce using rule 31 (expr -> - expr .)
    DO              reduce using rule 31 (expr -> - expr .)
    THEN            reduce using rule 31 (expr -> - expr .)
    ELSE            reduce using rule 31 (expr -> - expr .)


state 46

    (2) expression -> CAST VARIABLE_NAME TO VAR_TYPE .
    $end            reduce using rule 2 (expression -> CAST VARIABLE_NAME TO VAR_TYPE .)


state 47

    (4) expression -> PRINT LPAREN statement RPAREN .
    $end            reduce using rule 4 (expression -> PRINT LPAREN statement RPAREN .)


state 48

    (13) statement -> WHILE bool_op . DO statement
    DO              shift and go to state 68


state 49

    (22) bool_op -> expr . LE expr
    (23) bool_op -> expr . GE expr
    (24) bool_op -> expr . LT expr
    (25) bool_op -> expr . GT expr
    (26) bool_op -> expr . NEQ expr
    (27) bool_op -> expr . EQ expr
    (32) expr -> expr . / expr
    (33) expr -> expr . * expr
    (34) expr -> expr . - expr
    (35) expr -> expr . + expr
    LE              shift and go to state 51
    GE              shift and go to state 52
    LT              shift and go to state 53
    GT              shift and go to state 54
    NEQ             shift and go to state 55
    EQ              shift and go to state 56
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43


state 50

    (14) statement -> IF bool_op . THEN statement ELSE statement
    (15) statement -> IF bool_op . THEN statement
    THEN            shift and go to state 69


state 51

    (22) bool_op -> expr LE . expr
    (28) expr -> . VARIABLE_NAME
    (29) expr -> . variable_value
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . - expr
    (32) expr -> . expr / expr
    (33) expr -> . expr * expr
    (34) expr -> . expr - expr
    (35) expr -> . expr + expr
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    VARIABLE_NAME   shift and go to state 18
    LPAREN          shift and go to state 21
    -               shift and go to state 22
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    expr                           shift and go to state 70
    variable_value                 shift and go to state 20

state 52

    (23) bool_op -> expr GE . expr
    (28) expr -> . VARIABLE_NAME
    (29) expr -> . variable_value
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . - expr
    (32) expr -> . expr / expr
    (33) expr -> . expr * expr
    (34) expr -> . expr - expr
    (35) expr -> . expr + expr
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    VARIABLE_NAME   shift and go to state 18
    LPAREN          shift and go to state 21
    -               shift and go to state 22
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    expr                           shift and go to state 71
    variable_value                 shift and go to state 20

state 53

    (24) bool_op -> expr LT . expr
    (28) expr -> . VARIABLE_NAME
    (29) expr -> . variable_value
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . - expr
    (32) expr -> . expr / expr
    (33) expr -> . expr * expr
    (34) expr -> . expr - expr
    (35) expr -> . expr + expr
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    VARIABLE_NAME   shift and go to state 18
    LPAREN          shift and go to state 21
    -               shift and go to state 22
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    expr                           shift and go to state 72
    variable_value                 shift and go to state 20

state 54

    (25) bool_op -> expr GT . expr
    (28) expr -> . VARIABLE_NAME
    (29) expr -> . variable_value
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . - expr
    (32) expr -> . expr / expr
    (33) expr -> . expr * expr
    (34) expr -> . expr - expr
    (35) expr -> . expr + expr
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    VARIABLE_NAME   shift and go to state 18
    LPAREN          shift and go to state 21
    -               shift and go to state 22
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    expr                           shift and go to state 73
    variable_value                 shift and go to state 20

state 55

    (26) bool_op -> expr NEQ . expr
    (28) expr -> . VARIABLE_NAME
    (29) expr -> . variable_value
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . - expr
    (32) expr -> . expr / expr
    (33) expr -> . expr * expr
    (34) expr -> . expr - expr
    (35) expr -> . expr + expr
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    VARIABLE_NAME   shift and go to state 18
    LPAREN          shift and go to state 21
    -               shift and go to state 22
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    expr                           shift and go to state 74
    variable_value                 shift and go to state 20

state 56

    (27) bool_op -> expr EQ . expr
    (28) expr -> . VARIABLE_NAME
    (29) expr -> . variable_value
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . - expr
    (32) expr -> . expr / expr
    (33) expr -> . expr * expr
    (34) expr -> . expr - expr
    (35) expr -> . expr + expr
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    VARIABLE_NAME   shift and go to state 18
    LPAREN          shift and go to state 21
    -               shift and go to state 22
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    expr                           shift and go to state 75
    variable_value                 shift and go to state 20

state 57

    (18) statement -> VARIABLE_NAME L_SQUARE_BRACKETS . variable_value R_SQUARE_BRACKETS
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    variable_value                 shift and go to state 76

state 58

    (9) declaration -> CONSTANTS_PREFIX VARIABLE_NAME COLON VAR_TYPE . ASSIGN variable_value
    ASSIGN          shift and go to state 77


state 59

    (10) declaration -> CONSTANTS_PREFIX VARIABLE_NAME IS VAR_TYPE . ASSIGN variable_value
    ASSIGN          shift and go to state 78


state 60

    (11) declaration -> VARIABLE_PREFIX VARIABLE_NAME COLON VAR_TYPE . ASSIGN variable_value
    ASSIGN          shift and go to state 79


state 61

    (12) declaration -> VARIABLE_PREFIX VARIABLE_NAME IS VAR_TYPE . ASSIGN variable_value
    ASSIGN          shift and go to state 80


state 62

    (1) expression -> VARIABLE_NAME IS ARRAY OF VAR_TYPE . WITH L_SQUARE_BRACKETS value_list R_SQUARE_BRACKETS
    WITH            shift and go to state 81


state 63

    (32) expr -> expr / expr .
    (32) expr -> expr . / expr
    (33) expr -> expr . * expr
    (34) expr -> expr . - expr
    (35) expr -> expr . + expr
    /               reduce using rule 32 (expr -> expr / expr .)
    *               reduce using rule 32 (expr -> expr / expr .)
    -               reduce using rule 32 (expr -> expr / expr .)
    +               reduce using rule 32 (expr -> expr / expr .)
    $end            reduce using rule 32 (expr -> expr / expr .)
    LE              reduce using rule 32 (expr -> expr / expr .)
    GE              reduce using rule 32 (expr -> expr / expr .)
    LT              reduce using rule 32 (expr -> expr / expr .)
    GT              reduce using rule 32 (expr -> expr / expr .)
    NEQ             reduce using rule 32 (expr -> expr / expr .)
    EQ              reduce using rule 32 (expr -> expr / expr .)
    RPAREN          reduce using rule 32 (expr -> expr / expr .)
    DO              reduce using rule 32 (expr -> expr / expr .)
    THEN            reduce using rule 32 (expr -> expr / expr .)
    ELSE            reduce using rule 32 (expr -> expr / expr .)


state 64

    (33) expr -> expr * expr .
    (32) expr -> expr . / expr
    (33) expr -> expr . * expr
    (34) expr -> expr . - expr
    (35) expr -> expr . + expr
    /               reduce using rule 33 (expr -> expr * expr .)
    *               reduce using rule 33 (expr -> expr * expr .)
    -               reduce using rule 33 (expr -> expr * expr .)
    +               reduce using rule 33 (expr -> expr * expr .)
    $end            reduce using rule 33 (expr -> expr * expr .)
    LE              reduce using rule 33 (expr -> expr * expr .)
    GE              reduce using rule 33 (expr -> expr * expr .)
    LT              reduce using rule 33 (expr -> expr * expr .)
    GT              reduce using rule 33 (expr -> expr * expr .)
    NEQ             reduce using rule 33 (expr -> expr * expr .)
    EQ              reduce using rule 33 (expr -> expr * expr .)
    RPAREN          reduce using rule 33 (expr -> expr * expr .)
    DO              reduce using rule 33 (expr -> expr * expr .)
    THEN            reduce using rule 33 (expr -> expr * expr .)
    ELSE            reduce using rule 33 (expr -> expr * expr .)


state 65

    (34) expr -> expr - expr .
    (32) expr -> expr . / expr
    (33) expr -> expr . * expr
    (34) expr -> expr . - expr
    (35) expr -> expr . + expr
    -               reduce using rule 34 (expr -> expr - expr .)
    +               reduce using rule 34 (expr -> expr - expr .)
    $end            reduce using rule 34 (expr -> expr - expr .)
    LE              reduce using rule 34 (expr -> expr - expr .)
    GE              reduce using rule 34 (expr -> expr - expr .)
    LT              reduce using rule 34 (expr -> expr - expr .)
    GT              reduce using rule 34 (expr -> expr - expr .)
    NEQ             reduce using rule 34 (expr -> expr - expr .)
    EQ              reduce using rule 34 (expr -> expr - expr .)
    RPAREN          reduce using rule 34 (expr -> expr - expr .)
    DO              reduce using rule 34 (expr -> expr - expr .)
    THEN            reduce using rule 34 (expr -> expr - expr .)
    ELSE            reduce using rule 34 (expr -> expr - expr .)
    /               shift and go to state 40
    *               shift and go to state 41


state 66

    (35) expr -> expr + expr .
    (32) expr -> expr . / expr
    (33) expr -> expr . * expr
    (34) expr -> expr . - expr
    (35) expr -> expr . + expr
    -               reduce using rule 35 (expr -> expr + expr .)
    +               reduce using rule 35 (expr -> expr + expr .)
    $end            reduce using rule 35 (expr -> expr + expr .)
    LE              reduce using rule 35 (expr -> expr + expr .)
    GE              reduce using rule 35 (expr -> expr + expr .)
    LT              reduce using rule 35 (expr -> expr + expr .)
    GT              reduce using rule 35 (expr -> expr + expr .)
    NEQ             reduce using rule 35 (expr -> expr + expr .)
    EQ              reduce using rule 35 (expr -> expr + expr .)
    RPAREN          reduce using rule 35 (expr -> expr + expr .)
    DO              reduce using rule 35 (expr -> expr + expr .)
    THEN            reduce using rule 35 (expr -> expr + expr .)
    ELSE            reduce using rule 35 (expr -> expr + expr .)
    /               shift and go to state 40
    *               shift and go to state 41


state 67

    (30) expr -> LPAREN expr RPAREN .
    /               reduce using rule 30 (expr -> LPAREN expr RPAREN .)
    *               reduce using rule 30 (expr -> LPAREN expr RPAREN .)
    -               reduce using rule 30 (expr -> LPAREN expr RPAREN .)
    +               reduce using rule 30 (expr -> LPAREN expr RPAREN .)
    $end            reduce using rule 30 (expr -> LPAREN expr RPAREN .)
    LE              reduce using rule 30 (expr -> LPAREN expr RPAREN .)
    GE              reduce using rule 30 (expr -> LPAREN expr RPAREN .)
    LT              reduce using rule 30 (expr -> LPAREN expr RPAREN .)
    GT              reduce using rule 30 (expr -> LPAREN expr RPAREN .)
    NEQ             reduce using rule 30 (expr -> LPAREN expr RPAREN .)
    EQ              reduce using rule 30 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 30 (expr -> LPAREN expr RPAREN .)
    DO              reduce using rule 30 (expr -> LPAREN expr RPAREN .)
    THEN            reduce using rule 30 (expr -> LPAREN expr RPAREN .)
    ELSE            reduce using rule 30 (expr -> LPAREN expr RPAREN .)


state 68

    (13) statement -> WHILE bool_op DO . statement
    (13) statement -> . WHILE bool_op DO statement
    (14) statement -> . IF bool_op THEN statement ELSE statement
    (15) statement -> . IF bool_op THEN statement
    (16) statement -> . bool_op
    (17) statement -> . expr
    (18) statement -> . VARIABLE_NAME L_SQUARE_BRACKETS variable_value R_SQUARE_BRACKETS
    (19) statement -> . VARIABLE_NAME
    (20) statement -> . VARIABLES
    (21) statement -> . NAMES
    (22) bool_op -> . expr LE expr
    (23) bool_op -> . expr GE expr
    (24) bool_op -> . expr LT expr
    (25) bool_op -> . expr GT expr
    (26) bool_op -> . expr NEQ expr
    (27) bool_op -> . expr EQ expr
    (28) expr -> . VARIABLE_NAME
    (29) expr -> . variable_value
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . - expr
    (32) expr -> . expr / expr
    (33) expr -> . expr * expr
    (34) expr -> . expr - expr
    (35) expr -> . expr + expr
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    WHILE           shift and go to state 28
    IF              shift and go to state 30
    VARIABLE_NAME   shift and go to state 32
    VARIABLES       shift and go to state 33
    NAMES           shift and go to state 34
    LPAREN          shift and go to state 21
    -               shift and go to state 22
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    bool_op                        shift and go to state 29
    statement                      shift and go to state 82
    expr                           shift and go to state 31
    variable_value                 shift and go to state 20

state 69

    (14) statement -> IF bool_op THEN . statement ELSE statement
    (15) statement -> IF bool_op THEN . statement
    (13) statement -> . WHILE bool_op DO statement
    (14) statement -> . IF bool_op THEN statement ELSE statement
    (15) statement -> . IF bool_op THEN statement
    (16) statement -> . bool_op
    (17) statement -> . expr
    (18) statement -> . VARIABLE_NAME L_SQUARE_BRACKETS variable_value R_SQUARE_BRACKETS
    (19) statement -> . VARIABLE_NAME
    (20) statement -> . VARIABLES
    (21) statement -> . NAMES
    (22) bool_op -> . expr LE expr
    (23) bool_op -> . expr GE expr
    (24) bool_op -> . expr LT expr
    (25) bool_op -> . expr GT expr
    (26) bool_op -> . expr NEQ expr
    (27) bool_op -> . expr EQ expr
    (28) expr -> . VARIABLE_NAME
    (29) expr -> . variable_value
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . - expr
    (32) expr -> . expr / expr
    (33) expr -> . expr * expr
    (34) expr -> . expr - expr
    (35) expr -> . expr + expr
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    WHILE           shift and go to state 28
    IF              shift and go to state 30
    VARIABLE_NAME   shift and go to state 32
    VARIABLES       shift and go to state 33
    NAMES           shift and go to state 34
    LPAREN          shift and go to state 21
    -               shift and go to state 22
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    bool_op                        shift and go to state 29
    statement                      shift and go to state 83
    expr                           shift and go to state 31
    variable_value                 shift and go to state 20

state 70

    (22) bool_op -> expr LE expr .
    (32) expr -> expr . / expr
    (33) expr -> expr . * expr
    (34) expr -> expr . - expr
    (35) expr -> expr . + expr
    RPAREN          reduce using rule 22 (bool_op -> expr LE expr .)
    DO              reduce using rule 22 (bool_op -> expr LE expr .)
    THEN            reduce using rule 22 (bool_op -> expr LE expr .)
    ELSE            reduce using rule 22 (bool_op -> expr LE expr .)
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43


state 71

    (23) bool_op -> expr GE expr .
    (32) expr -> expr . / expr
    (33) expr -> expr . * expr
    (34) expr -> expr . - expr
    (35) expr -> expr . + expr
    RPAREN          reduce using rule 23 (bool_op -> expr GE expr .)
    DO              reduce using rule 23 (bool_op -> expr GE expr .)
    THEN            reduce using rule 23 (bool_op -> expr GE expr .)
    ELSE            reduce using rule 23 (bool_op -> expr GE expr .)
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43


state 72

    (24) bool_op -> expr LT expr .
    (32) expr -> expr . / expr
    (33) expr -> expr . * expr
    (34) expr -> expr . - expr
    (35) expr -> expr . + expr
    RPAREN          reduce using rule 24 (bool_op -> expr LT expr .)
    DO              reduce using rule 24 (bool_op -> expr LT expr .)
    THEN            reduce using rule 24 (bool_op -> expr LT expr .)
    ELSE            reduce using rule 24 (bool_op -> expr LT expr .)
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43


state 73

    (25) bool_op -> expr GT expr .
    (32) expr -> expr . / expr
    (33) expr -> expr . * expr
    (34) expr -> expr . - expr
    (35) expr -> expr . + expr
    RPAREN          reduce using rule 25 (bool_op -> expr GT expr .)
    DO              reduce using rule 25 (bool_op -> expr GT expr .)
    THEN            reduce using rule 25 (bool_op -> expr GT expr .)
    ELSE            reduce using rule 25 (bool_op -> expr GT expr .)
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43


state 74

    (26) bool_op -> expr NEQ expr .
    (32) expr -> expr . / expr
    (33) expr -> expr . * expr
    (34) expr -> expr . - expr
    (35) expr -> expr . + expr
    RPAREN          reduce using rule 26 (bool_op -> expr NEQ expr .)
    DO              reduce using rule 26 (bool_op -> expr NEQ expr .)
    THEN            reduce using rule 26 (bool_op -> expr NEQ expr .)
    ELSE            reduce using rule 26 (bool_op -> expr NEQ expr .)
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43


state 75

    (27) bool_op -> expr EQ expr .
    (32) expr -> expr . / expr
    (33) expr -> expr . * expr
    (34) expr -> expr . - expr
    (35) expr -> expr . + expr
    RPAREN          reduce using rule 27 (bool_op -> expr EQ expr .)
    DO              reduce using rule 27 (bool_op -> expr EQ expr .)
    THEN            reduce using rule 27 (bool_op -> expr EQ expr .)
    ELSE            reduce using rule 27 (bool_op -> expr EQ expr .)
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43


state 76

    (18) statement -> VARIABLE_NAME L_SQUARE_BRACKETS variable_value . R_SQUARE_BRACKETS
    R_SQUARE_BRACKETS shift and go to state 84


state 77

    (9) declaration -> CONSTANTS_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN . variable_value
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    variable_value                 shift and go to state 85

state 78

    (10) declaration -> CONSTANTS_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN . variable_value
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    variable_value                 shift and go to state 86

state 79

    (11) declaration -> VARIABLE_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN . variable_value
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    variable_value                 shift and go to state 87

state 80

    (12) declaration -> VARIABLE_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN . variable_value
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    variable_value                 shift and go to state 88

state 81

    (1) expression -> VARIABLE_NAME IS ARRAY OF VAR_TYPE WITH . L_SQUARE_BRACKETS value_list R_SQUARE_BRACKETS
    L_SQUARE_BRACKETS shift and go to state 89


state 82

    (13) statement -> WHILE bool_op DO statement .
    RPAREN          reduce using rule 13 (statement -> WHILE bool_op DO statement .)
    ELSE            reduce using rule 13 (statement -> WHILE bool_op DO statement .)


state 83

    (14) statement -> IF bool_op THEN statement . ELSE statement
    (15) statement -> IF bool_op THEN statement .
  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 90
    RPAREN          reduce using rule 15 (statement -> IF bool_op THEN statement .)


state 84

    (18) statement -> VARIABLE_NAME L_SQUARE_BRACKETS variable_value R_SQUARE_BRACKETS .
    RPAREN          reduce using rule 18 (statement -> VARIABLE_NAME L_SQUARE_BRACKETS variable_value R_SQUARE_BRACKETS .)
    ELSE            reduce using rule 18 (statement -> VARIABLE_NAME L_SQUARE_BRACKETS variable_value R_SQUARE_BRACKETS .)


state 85

    (9) declaration -> CONSTANTS_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN variable_value .
    CONSTANTS_PREFIX reduce using rule 9 (declaration -> CONSTANTS_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN variable_value .)
    VARIABLE_PREFIX reduce using rule 9 (declaration -> CONSTANTS_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN variable_value .)
    $end            reduce using rule 9 (declaration -> CONSTANTS_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN variable_value .)


state 86

    (10) declaration -> CONSTANTS_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN variable_value .
    CONSTANTS_PREFIX reduce using rule 10 (declaration -> CONSTANTS_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN variable_value .)
    VARIABLE_PREFIX reduce using rule 10 (declaration -> CONSTANTS_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN variable_value .)
    $end            reduce using rule 10 (declaration -> CONSTANTS_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN variable_value .)


state 87

    (11) declaration -> VARIABLE_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN variable_value .
    CONSTANTS_PREFIX reduce using rule 11 (declaration -> VARIABLE_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN variable_value .)
    VARIABLE_PREFIX reduce using rule 11 (declaration -> VARIABLE_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN variable_value .)
    $end            reduce using rule 11 (declaration -> VARIABLE_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN variable_value .)


state 88

    (12) declaration -> VARIABLE_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN variable_value .
    CONSTANTS_PREFIX reduce using rule 12 (declaration -> VARIABLE_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN variable_value .)
    VARIABLE_PREFIX reduce using rule 12 (declaration -> VARIABLE_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN variable_value .)
    $end            reduce using rule 12 (declaration -> VARIABLE_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN variable_value .)


state 89

    (1) expression -> VARIABLE_NAME IS ARRAY OF VAR_TYPE WITH L_SQUARE_BRACKETS . value_list R_SQUARE_BRACKETS
    (36) value_list -> . variable_value
    (37) value_list -> . variable_value COMMA value_list
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    value_list                     shift and go to state 91
    variable_value                 shift and go to state 92

state 90

    (14) statement -> IF bool_op THEN statement ELSE . statement
    (13) statement -> . WHILE bool_op DO statement
    (14) statement -> . IF bool_op THEN statement ELSE statement
    (15) statement -> . IF bool_op THEN statement
    (16) statement -> . bool_op
    (17) statement -> . expr
    (18) statement -> . VARIABLE_NAME L_SQUARE_BRACKETS variable_value R_SQUARE_BRACKETS
    (19) statement -> . VARIABLE_NAME
    (20) statement -> . VARIABLES
    (21) statement -> . NAMES
    (22) bool_op -> . expr LE expr
    (23) bool_op -> . expr GE expr
    (24) bool_op -> . expr LT expr
    (25) bool_op -> . expr GT expr
    (26) bool_op -> . expr NEQ expr
    (27) bool_op -> . expr EQ expr
    (28) expr -> . VARIABLE_NAME
    (29) expr -> . variable_value
    (30) expr -> . LPAREN expr RPAREN
    (31) expr -> . - expr
    (32) expr -> . expr / expr
    (33) expr -> . expr * expr
    (34) expr -> . expr - expr
    (35) expr -> . expr + expr
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    WHILE           shift and go to state 28
    IF              shift and go to state 30
    VARIABLE_NAME   shift and go to state 32
    VARIABLES       shift and go to state 33
    NAMES           shift and go to state 34
    LPAREN          shift and go to state 21
    -               shift and go to state 22
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    bool_op                        shift and go to state 29
    statement                      shift and go to state 93
    expr                           shift and go to state 31
    variable_value                 shift and go to state 20

state 91

    (1) expression -> VARIABLE_NAME IS ARRAY OF VAR_TYPE WITH L_SQUARE_BRACKETS value_list . R_SQUARE_BRACKETS
    R_SQUARE_BRACKETS shift and go to state 94


state 92

    (36) value_list -> variable_value .
    (37) value_list -> variable_value . COMMA value_list
    R_SQUARE_BRACKETS reduce using rule 36 (value_list -> variable_value .)
    COMMA           shift and go to state 95


state 93

    (14) statement -> IF bool_op THEN statement ELSE statement .
    RPAREN          reduce using rule 14 (statement -> IF bool_op THEN statement ELSE statement .)
    ELSE            reduce using rule 14 (statement -> IF bool_op THEN statement ELSE statement .)


state 94

    (1) expression -> VARIABLE_NAME IS ARRAY OF VAR_TYPE WITH L_SQUARE_BRACKETS value_list R_SQUARE_BRACKETS .
    $end            reduce using rule 1 (expression -> VARIABLE_NAME IS ARRAY OF VAR_TYPE WITH L_SQUARE_BRACKETS value_list R_SQUARE_BRACKETS .)


state 95

    (37) value_list -> variable_value COMMA . value_list
    (36) value_list -> . variable_value
    (37) value_list -> . variable_value COMMA value_list
    (38) variable_value -> . STRING_VALUE
    (39) variable_value -> . FLOAT_VALUE
    (40) variable_value -> . INTEGER_VALUE
    STRING_VALUE    shift and go to state 23
    FLOAT_VALUE     shift and go to state 24
    INTEGER_VALUE   shift and go to state 25

    variable_value                 shift and go to state 92
    value_list                     shift and go to state 96

state 96

    (37) value_list -> variable_value COMMA value_list .
    R_SQUARE_BRACKETS reduce using rule 37 (value_list -> variable_value COMMA value_list .)


Conflicts:

shift/reduce conflict for ELSE in state 83 resolved as shift
reduce/reduce conflict in state 32 resolved using rule statement -> VARIABLE_NAME
rejected rule (expr -> VARIABLE_NAME) in state 32