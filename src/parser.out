Grammar:

Rule 0     S' -> expression
Rule 1     expression -> VARIABLE_NAME IS ARRAY OF VAR_TYPE WITH L_SQUARE_BRACKETS value_list R_SQUARE_BRACKETS
Rule 2     expression -> CAST VARIABLE_NAME TO VAR_TYPE
Rule 3     expression -> VARIABLE_NAME ASSIGN expr
Rule 4     expression -> PRINT LPAREN statement RPAREN
Rule 5     expression -> COMMENT
Rule 6     expression -> declaration_list
Rule 7     declaration_list -> declaration declaration_list
Rule 8     declaration_list -> declaration
Rule 9     declaration -> CONSTANTS_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN VARIABLE_VALUE
Rule 10    declaration -> CONSTANTS_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN VARIABLE_VALUE
Rule 11    declaration -> VARIABLE_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN VARIABLE_VALUE
Rule 12    declaration -> VARIABLE_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN VARIABLE_VALUE
Rule 13    statement -> WHILE bool_op DO statement
Rule 14    statement -> IF bool_op THEN statement ELSE statement
Rule 15    statement -> IF bool_op THEN statement
Rule 16    statement -> bool_op
Rule 17    statement -> expr
Rule 18    statement -> VARIABLE_NAME L_SQUARE_BRACKETS VARIABLE_VALUE R_SQUARE_BRACKETS
Rule 19    statement -> VARIABLE_NAME
Rule 20    statement -> VARIABLES
Rule 21    statement -> NAMES
Rule 22    bool_op -> expr LE expr
Rule 23    bool_op -> expr GE expr
Rule 24    bool_op -> expr LT expr
Rule 25    bool_op -> expr GT expr
Rule 26    bool_op -> expr EQ expr
Rule 27    expr -> VARIABLE_NAME
Rule 28    expr -> VARIABLE_VALUE
Rule 29    expr -> LPAREN expr RPAREN
Rule 30    expr -> - expr  [precedence=right, level=3]
Rule 31    expr -> expr / expr  [precedence=left, level=2]
Rule 32    expr -> expr * expr  [precedence=left, level=2]
Rule 33    expr -> expr - expr  [precedence=left, level=1]
Rule 34    expr -> expr + expr  [precedence=left, level=1]
Rule 35    value_list -> VARIABLE_VALUE
Rule 36    value_list -> VARIABLE_VALUE COMMA value_list

Terminals, with rules where they appear:

*                    : 32
+                    : 34
-                    : 30 33
/                    : 31
ARRAY                : 1
ASSIGN               : 3 9 10 11 12
CAST                 : 2
COLON                : 9 11
COMMA                : 36
COMMENT              : 5
CONSTANTS_PREFIX     : 9 10
DO                   : 13
ELSE                 : 14
EQ                   : 26
GE                   : 23
GT                   : 25
IF                   : 14 15
IS                   : 1 10 12
LE                   : 22
LPAREN               : 4 29
LT                   : 24
L_SQUARE_BRACKETS    : 1 18
NAMES                : 21
OF                   : 1
PRINT                : 4
RPAREN               : 4 29
R_SQUARE_BRACKETS    : 1 18
THEN                 : 14 15
TO                   : 2
VARIABLES            : 20
VARIABLE_NAME        : 1 2 3 9 10 11 12 18 19 27
VARIABLE_PREFIX      : 11 12
VARIABLE_VALUE       : 9 10 11 12 18 28 35 36
VAR_TYPE             : 1 2 9 10 11 12
WHILE                : 13
WITH                 : 1
error                : 

Nonterminals, with rules where they appear:

bool_op              : 13 14 15 16
declaration          : 7 8
declaration_list     : 6 7
expr                 : 3 17 22 22 23 23 24 24 25 25 26 26 29 30 31 31 32 32 33 33 34 34
expression           : 0
statement            : 4 13 14 14 15
value_list           : 1 36


state 0

    (0) S' -> . expression
    (1) expression -> . VARIABLE_NAME IS ARRAY OF VAR_TYPE WITH L_SQUARE_BRACKETS value_list R_SQUARE_BRACKETS
    (2) expression -> . CAST VARIABLE_NAME TO VAR_TYPE
    (3) expression -> . VARIABLE_NAME ASSIGN expr
    (4) expression -> . PRINT LPAREN statement RPAREN
    (5) expression -> . COMMENT
    (6) expression -> . declaration_list
    (7) declaration_list -> . declaration declaration_list
    (8) declaration_list -> . declaration
    (9) declaration -> . CONSTANTS_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN VARIABLE_VALUE
    (10) declaration -> . CONSTANTS_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN VARIABLE_VALUE
    (11) declaration -> . VARIABLE_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN VARIABLE_VALUE
    (12) declaration -> . VARIABLE_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN VARIABLE_VALUE
    VARIABLE_NAME   shift and go to state 2
    CAST            shift and go to state 3
    PRINT           shift and go to state 4
    COMMENT         shift and go to state 5
    CONSTANTS_PREFIX shift and go to state 8
    VARIABLE_PREFIX shift and go to state 9

    expression                     shift and go to state 1
    declaration_list               shift and go to state 6
    declaration                    shift and go to state 7

state 1

    (0) S' -> expression .


state 2

    (1) expression -> VARIABLE_NAME . IS ARRAY OF VAR_TYPE WITH L_SQUARE_BRACKETS value_list R_SQUARE_BRACKETS
    (3) expression -> VARIABLE_NAME . ASSIGN expr
    IS              shift and go to state 10
    ASSIGN          shift and go to state 11


state 3

    (2) expression -> CAST . VARIABLE_NAME TO VAR_TYPE
    VARIABLE_NAME   shift and go to state 12


state 4

    (4) expression -> PRINT . LPAREN statement RPAREN
    LPAREN          shift and go to state 13


state 5

    (5) expression -> COMMENT .
    $end            reduce using rule 5 (expression -> COMMENT .)


state 6

    (6) expression -> declaration_list .
    $end            reduce using rule 6 (expression -> declaration_list .)


state 7

    (7) declaration_list -> declaration . declaration_list
    (8) declaration_list -> declaration .
    (7) declaration_list -> . declaration declaration_list
    (8) declaration_list -> . declaration
    (9) declaration -> . CONSTANTS_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN VARIABLE_VALUE
    (10) declaration -> . CONSTANTS_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN VARIABLE_VALUE
    (11) declaration -> . VARIABLE_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN VARIABLE_VALUE
    (12) declaration -> . VARIABLE_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN VARIABLE_VALUE
    $end            reduce using rule 8 (declaration_list -> declaration .)
    CONSTANTS_PREFIX shift and go to state 8
    VARIABLE_PREFIX shift and go to state 9

    declaration                    shift and go to state 7
    declaration_list               shift and go to state 14

state 8

    (9) declaration -> CONSTANTS_PREFIX . VARIABLE_NAME COLON VAR_TYPE ASSIGN VARIABLE_VALUE
    (10) declaration -> CONSTANTS_PREFIX . VARIABLE_NAME IS VAR_TYPE ASSIGN VARIABLE_VALUE
    VARIABLE_NAME   shift and go to state 15


state 9

    (11) declaration -> VARIABLE_PREFIX . VARIABLE_NAME COLON VAR_TYPE ASSIGN VARIABLE_VALUE
    (12) declaration -> VARIABLE_PREFIX . VARIABLE_NAME IS VAR_TYPE ASSIGN VARIABLE_VALUE
    VARIABLE_NAME   shift and go to state 16


state 10

    (1) expression -> VARIABLE_NAME IS . ARRAY OF VAR_TYPE WITH L_SQUARE_BRACKETS value_list R_SQUARE_BRACKETS
    ARRAY           shift and go to state 17


state 11

    (3) expression -> VARIABLE_NAME ASSIGN . expr
    (27) expr -> . VARIABLE_NAME
    (28) expr -> . VARIABLE_VALUE
    (29) expr -> . LPAREN expr RPAREN
    (30) expr -> . - expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    VARIABLE_NAME   shift and go to state 18
    VARIABLE_VALUE  shift and go to state 20
    LPAREN          shift and go to state 21
    -               shift and go to state 22

    expr                           shift and go to state 19

state 12

    (2) expression -> CAST VARIABLE_NAME . TO VAR_TYPE
    TO              shift and go to state 23


state 13

    (4) expression -> PRINT LPAREN . statement RPAREN
    (13) statement -> . WHILE bool_op DO statement
    (14) statement -> . IF bool_op THEN statement ELSE statement
    (15) statement -> . IF bool_op THEN statement
    (16) statement -> . bool_op
    (17) statement -> . expr
    (18) statement -> . VARIABLE_NAME L_SQUARE_BRACKETS VARIABLE_VALUE R_SQUARE_BRACKETS
    (19) statement -> . VARIABLE_NAME
    (20) statement -> . VARIABLES
    (21) statement -> . NAMES
    (22) bool_op -> . expr LE expr
    (23) bool_op -> . expr GE expr
    (24) bool_op -> . expr LT expr
    (25) bool_op -> . expr GT expr
    (26) bool_op -> . expr EQ expr
    (27) expr -> . VARIABLE_NAME
    (28) expr -> . VARIABLE_VALUE
    (29) expr -> . LPAREN expr RPAREN
    (30) expr -> . - expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    WHILE           shift and go to state 25
    IF              shift and go to state 27
    VARIABLE_NAME   shift and go to state 29
    VARIABLES       shift and go to state 30
    NAMES           shift and go to state 31
    VARIABLE_VALUE  shift and go to state 20
    LPAREN          shift and go to state 21
    -               shift and go to state 22

    statement                      shift and go to state 24
    bool_op                        shift and go to state 26
    expr                           shift and go to state 28

state 14

    (7) declaration_list -> declaration declaration_list .
    $end            reduce using rule 7 (declaration_list -> declaration declaration_list .)


state 15

    (9) declaration -> CONSTANTS_PREFIX VARIABLE_NAME . COLON VAR_TYPE ASSIGN VARIABLE_VALUE
    (10) declaration -> CONSTANTS_PREFIX VARIABLE_NAME . IS VAR_TYPE ASSIGN VARIABLE_VALUE
    COLON           shift and go to state 32
    IS              shift and go to state 33


state 16

    (11) declaration -> VARIABLE_PREFIX VARIABLE_NAME . COLON VAR_TYPE ASSIGN VARIABLE_VALUE
    (12) declaration -> VARIABLE_PREFIX VARIABLE_NAME . IS VAR_TYPE ASSIGN VARIABLE_VALUE
    COLON           shift and go to state 34
    IS              shift and go to state 35


state 17

    (1) expression -> VARIABLE_NAME IS ARRAY . OF VAR_TYPE WITH L_SQUARE_BRACKETS value_list R_SQUARE_BRACKETS
    OF              shift and go to state 36


state 18

    (27) expr -> VARIABLE_NAME .
    /               reduce using rule 27 (expr -> VARIABLE_NAME .)
    *               reduce using rule 27 (expr -> VARIABLE_NAME .)
    -               reduce using rule 27 (expr -> VARIABLE_NAME .)
    +               reduce using rule 27 (expr -> VARIABLE_NAME .)
    $end            reduce using rule 27 (expr -> VARIABLE_NAME .)
    RPAREN          reduce using rule 27 (expr -> VARIABLE_NAME .)
    LE              reduce using rule 27 (expr -> VARIABLE_NAME .)
    GE              reduce using rule 27 (expr -> VARIABLE_NAME .)
    LT              reduce using rule 27 (expr -> VARIABLE_NAME .)
    GT              reduce using rule 27 (expr -> VARIABLE_NAME .)
    EQ              reduce using rule 27 (expr -> VARIABLE_NAME .)
    DO              reduce using rule 27 (expr -> VARIABLE_NAME .)
    THEN            reduce using rule 27 (expr -> VARIABLE_NAME .)
    ELSE            reduce using rule 27 (expr -> VARIABLE_NAME .)


state 19

    (3) expression -> VARIABLE_NAME ASSIGN expr .
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    $end            reduce using rule 3 (expression -> VARIABLE_NAME ASSIGN expr .)
    /               shift and go to state 37
    *               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40


state 20

    (28) expr -> VARIABLE_VALUE .
    /               reduce using rule 28 (expr -> VARIABLE_VALUE .)
    *               reduce using rule 28 (expr -> VARIABLE_VALUE .)
    -               reduce using rule 28 (expr -> VARIABLE_VALUE .)
    +               reduce using rule 28 (expr -> VARIABLE_VALUE .)
    $end            reduce using rule 28 (expr -> VARIABLE_VALUE .)
    LE              reduce using rule 28 (expr -> VARIABLE_VALUE .)
    GE              reduce using rule 28 (expr -> VARIABLE_VALUE .)
    LT              reduce using rule 28 (expr -> VARIABLE_VALUE .)
    GT              reduce using rule 28 (expr -> VARIABLE_VALUE .)
    EQ              reduce using rule 28 (expr -> VARIABLE_VALUE .)
    RPAREN          reduce using rule 28 (expr -> VARIABLE_VALUE .)
    DO              reduce using rule 28 (expr -> VARIABLE_VALUE .)
    THEN            reduce using rule 28 (expr -> VARIABLE_VALUE .)
    ELSE            reduce using rule 28 (expr -> VARIABLE_VALUE .)


state 21

    (29) expr -> LPAREN . expr RPAREN
    (27) expr -> . VARIABLE_NAME
    (28) expr -> . VARIABLE_VALUE
    (29) expr -> . LPAREN expr RPAREN
    (30) expr -> . - expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    VARIABLE_NAME   shift and go to state 18
    VARIABLE_VALUE  shift and go to state 20
    LPAREN          shift and go to state 21
    -               shift and go to state 22

    expr                           shift and go to state 41

state 22

    (30) expr -> - . expr
    (27) expr -> . VARIABLE_NAME
    (28) expr -> . VARIABLE_VALUE
    (29) expr -> . LPAREN expr RPAREN
    (30) expr -> . - expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    VARIABLE_NAME   shift and go to state 18
    VARIABLE_VALUE  shift and go to state 20
    LPAREN          shift and go to state 21
    -               shift and go to state 22

    expr                           shift and go to state 42

state 23

    (2) expression -> CAST VARIABLE_NAME TO . VAR_TYPE
    VAR_TYPE        shift and go to state 43


state 24

    (4) expression -> PRINT LPAREN statement . RPAREN
    RPAREN          shift and go to state 44


state 25

    (13) statement -> WHILE . bool_op DO statement
    (22) bool_op -> . expr LE expr
    (23) bool_op -> . expr GE expr
    (24) bool_op -> . expr LT expr
    (25) bool_op -> . expr GT expr
    (26) bool_op -> . expr EQ expr
    (27) expr -> . VARIABLE_NAME
    (28) expr -> . VARIABLE_VALUE
    (29) expr -> . LPAREN expr RPAREN
    (30) expr -> . - expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    VARIABLE_NAME   shift and go to state 18
    VARIABLE_VALUE  shift and go to state 20
    LPAREN          shift and go to state 21
    -               shift and go to state 22

    bool_op                        shift and go to state 45
    expr                           shift and go to state 46

state 26

    (16) statement -> bool_op .
    RPAREN          reduce using rule 16 (statement -> bool_op .)
    ELSE            reduce using rule 16 (statement -> bool_op .)


state 27

    (14) statement -> IF . bool_op THEN statement ELSE statement
    (15) statement -> IF . bool_op THEN statement
    (22) bool_op -> . expr LE expr
    (23) bool_op -> . expr GE expr
    (24) bool_op -> . expr LT expr
    (25) bool_op -> . expr GT expr
    (26) bool_op -> . expr EQ expr
    (27) expr -> . VARIABLE_NAME
    (28) expr -> . VARIABLE_VALUE
    (29) expr -> . LPAREN expr RPAREN
    (30) expr -> . - expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    VARIABLE_NAME   shift and go to state 18
    VARIABLE_VALUE  shift and go to state 20
    LPAREN          shift and go to state 21
    -               shift and go to state 22

    bool_op                        shift and go to state 47
    expr                           shift and go to state 46

state 28

    (17) statement -> expr .
    (22) bool_op -> expr . LE expr
    (23) bool_op -> expr . GE expr
    (24) bool_op -> expr . LT expr
    (25) bool_op -> expr . GT expr
    (26) bool_op -> expr . EQ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    RPAREN          reduce using rule 17 (statement -> expr .)
    ELSE            reduce using rule 17 (statement -> expr .)
    LE              shift and go to state 48
    GE              shift and go to state 49
    LT              shift and go to state 50
    GT              shift and go to state 51
    EQ              shift and go to state 52
    /               shift and go to state 37
    *               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40


state 29

    (18) statement -> VARIABLE_NAME . L_SQUARE_BRACKETS VARIABLE_VALUE R_SQUARE_BRACKETS
    (19) statement -> VARIABLE_NAME .
    (27) expr -> VARIABLE_NAME .
  ! reduce/reduce conflict for RPAREN resolved using rule 19 (statement -> VARIABLE_NAME .)
  ! reduce/reduce conflict for ELSE resolved using rule 19 (statement -> VARIABLE_NAME .)
    L_SQUARE_BRACKETS shift and go to state 53
    RPAREN          reduce using rule 19 (statement -> VARIABLE_NAME .)
    ELSE            reduce using rule 19 (statement -> VARIABLE_NAME .)
    LE              reduce using rule 27 (expr -> VARIABLE_NAME .)
    GE              reduce using rule 27 (expr -> VARIABLE_NAME .)
    LT              reduce using rule 27 (expr -> VARIABLE_NAME .)
    GT              reduce using rule 27 (expr -> VARIABLE_NAME .)
    EQ              reduce using rule 27 (expr -> VARIABLE_NAME .)
    /               reduce using rule 27 (expr -> VARIABLE_NAME .)
    *               reduce using rule 27 (expr -> VARIABLE_NAME .)
    -               reduce using rule 27 (expr -> VARIABLE_NAME .)
    +               reduce using rule 27 (expr -> VARIABLE_NAME .)


state 30

    (20) statement -> VARIABLES .
    RPAREN          reduce using rule 20 (statement -> VARIABLES .)
    ELSE            reduce using rule 20 (statement -> VARIABLES .)


state 31

    (21) statement -> NAMES .
    RPAREN          reduce using rule 21 (statement -> NAMES .)
    ELSE            reduce using rule 21 (statement -> NAMES .)


state 32

    (9) declaration -> CONSTANTS_PREFIX VARIABLE_NAME COLON . VAR_TYPE ASSIGN VARIABLE_VALUE
    VAR_TYPE        shift and go to state 54


state 33

    (10) declaration -> CONSTANTS_PREFIX VARIABLE_NAME IS . VAR_TYPE ASSIGN VARIABLE_VALUE
    VAR_TYPE        shift and go to state 55


state 34

    (11) declaration -> VARIABLE_PREFIX VARIABLE_NAME COLON . VAR_TYPE ASSIGN VARIABLE_VALUE
    VAR_TYPE        shift and go to state 56


state 35

    (12) declaration -> VARIABLE_PREFIX VARIABLE_NAME IS . VAR_TYPE ASSIGN VARIABLE_VALUE
    VAR_TYPE        shift and go to state 57


state 36

    (1) expression -> VARIABLE_NAME IS ARRAY OF . VAR_TYPE WITH L_SQUARE_BRACKETS value_list R_SQUARE_BRACKETS
    VAR_TYPE        shift and go to state 58


state 37

    (31) expr -> expr / . expr
    (27) expr -> . VARIABLE_NAME
    (28) expr -> . VARIABLE_VALUE
    (29) expr -> . LPAREN expr RPAREN
    (30) expr -> . - expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    VARIABLE_NAME   shift and go to state 18
    VARIABLE_VALUE  shift and go to state 20
    LPAREN          shift and go to state 21
    -               shift and go to state 22

    expr                           shift and go to state 59

state 38

    (32) expr -> expr * . expr
    (27) expr -> . VARIABLE_NAME
    (28) expr -> . VARIABLE_VALUE
    (29) expr -> . LPAREN expr RPAREN
    (30) expr -> . - expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    VARIABLE_NAME   shift and go to state 18
    VARIABLE_VALUE  shift and go to state 20
    LPAREN          shift and go to state 21
    -               shift and go to state 22

    expr                           shift and go to state 60

state 39

    (33) expr -> expr - . expr
    (27) expr -> . VARIABLE_NAME
    (28) expr -> . VARIABLE_VALUE
    (29) expr -> . LPAREN expr RPAREN
    (30) expr -> . - expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    VARIABLE_NAME   shift and go to state 18
    VARIABLE_VALUE  shift and go to state 20
    LPAREN          shift and go to state 21
    -               shift and go to state 22

    expr                           shift and go to state 61

state 40

    (34) expr -> expr + . expr
    (27) expr -> . VARIABLE_NAME
    (28) expr -> . VARIABLE_VALUE
    (29) expr -> . LPAREN expr RPAREN
    (30) expr -> . - expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    VARIABLE_NAME   shift and go to state 18
    VARIABLE_VALUE  shift and go to state 20
    LPAREN          shift and go to state 21
    -               shift and go to state 22

    expr                           shift and go to state 62

state 41

    (29) expr -> LPAREN expr . RPAREN
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    RPAREN          shift and go to state 63
    /               shift and go to state 37
    *               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40


state 42

    (30) expr -> - expr .
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    /               reduce using rule 30 (expr -> - expr .)
    *               reduce using rule 30 (expr -> - expr .)
    -               reduce using rule 30 (expr -> - expr .)
    +               reduce using rule 30 (expr -> - expr .)
    $end            reduce using rule 30 (expr -> - expr .)
    LE              reduce using rule 30 (expr -> - expr .)
    GE              reduce using rule 30 (expr -> - expr .)
    LT              reduce using rule 30 (expr -> - expr .)
    GT              reduce using rule 30 (expr -> - expr .)
    EQ              reduce using rule 30 (expr -> - expr .)
    RPAREN          reduce using rule 30 (expr -> - expr .)
    DO              reduce using rule 30 (expr -> - expr .)
    THEN            reduce using rule 30 (expr -> - expr .)
    ELSE            reduce using rule 30 (expr -> - expr .)


state 43

    (2) expression -> CAST VARIABLE_NAME TO VAR_TYPE .
    $end            reduce using rule 2 (expression -> CAST VARIABLE_NAME TO VAR_TYPE .)


state 44

    (4) expression -> PRINT LPAREN statement RPAREN .
    $end            reduce using rule 4 (expression -> PRINT LPAREN statement RPAREN .)


state 45

    (13) statement -> WHILE bool_op . DO statement
    DO              shift and go to state 64


state 46

    (22) bool_op -> expr . LE expr
    (23) bool_op -> expr . GE expr
    (24) bool_op -> expr . LT expr
    (25) bool_op -> expr . GT expr
    (26) bool_op -> expr . EQ expr
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    LE              shift and go to state 48
    GE              shift and go to state 49
    LT              shift and go to state 50
    GT              shift and go to state 51
    EQ              shift and go to state 52
    /               shift and go to state 37
    *               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40


state 47

    (14) statement -> IF bool_op . THEN statement ELSE statement
    (15) statement -> IF bool_op . THEN statement
    THEN            shift and go to state 65


state 48

    (22) bool_op -> expr LE . expr
    (27) expr -> . VARIABLE_NAME
    (28) expr -> . VARIABLE_VALUE
    (29) expr -> . LPAREN expr RPAREN
    (30) expr -> . - expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    VARIABLE_NAME   shift and go to state 18
    VARIABLE_VALUE  shift and go to state 20
    LPAREN          shift and go to state 21
    -               shift and go to state 22

    expr                           shift and go to state 66

state 49

    (23) bool_op -> expr GE . expr
    (27) expr -> . VARIABLE_NAME
    (28) expr -> . VARIABLE_VALUE
    (29) expr -> . LPAREN expr RPAREN
    (30) expr -> . - expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    VARIABLE_NAME   shift and go to state 18
    VARIABLE_VALUE  shift and go to state 20
    LPAREN          shift and go to state 21
    -               shift and go to state 22

    expr                           shift and go to state 67

state 50

    (24) bool_op -> expr LT . expr
    (27) expr -> . VARIABLE_NAME
    (28) expr -> . VARIABLE_VALUE
    (29) expr -> . LPAREN expr RPAREN
    (30) expr -> . - expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    VARIABLE_NAME   shift and go to state 18
    VARIABLE_VALUE  shift and go to state 20
    LPAREN          shift and go to state 21
    -               shift and go to state 22

    expr                           shift and go to state 68

state 51

    (25) bool_op -> expr GT . expr
    (27) expr -> . VARIABLE_NAME
    (28) expr -> . VARIABLE_VALUE
    (29) expr -> . LPAREN expr RPAREN
    (30) expr -> . - expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    VARIABLE_NAME   shift and go to state 18
    VARIABLE_VALUE  shift and go to state 20
    LPAREN          shift and go to state 21
    -               shift and go to state 22

    expr                           shift and go to state 69

state 52

    (26) bool_op -> expr EQ . expr
    (27) expr -> . VARIABLE_NAME
    (28) expr -> . VARIABLE_VALUE
    (29) expr -> . LPAREN expr RPAREN
    (30) expr -> . - expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    VARIABLE_NAME   shift and go to state 18
    VARIABLE_VALUE  shift and go to state 20
    LPAREN          shift and go to state 21
    -               shift and go to state 22

    expr                           shift and go to state 70

state 53

    (18) statement -> VARIABLE_NAME L_SQUARE_BRACKETS . VARIABLE_VALUE R_SQUARE_BRACKETS
    VARIABLE_VALUE  shift and go to state 71


state 54

    (9) declaration -> CONSTANTS_PREFIX VARIABLE_NAME COLON VAR_TYPE . ASSIGN VARIABLE_VALUE
    ASSIGN          shift and go to state 72


state 55

    (10) declaration -> CONSTANTS_PREFIX VARIABLE_NAME IS VAR_TYPE . ASSIGN VARIABLE_VALUE
    ASSIGN          shift and go to state 73


state 56

    (11) declaration -> VARIABLE_PREFIX VARIABLE_NAME COLON VAR_TYPE . ASSIGN VARIABLE_VALUE
    ASSIGN          shift and go to state 74


state 57

    (12) declaration -> VARIABLE_PREFIX VARIABLE_NAME IS VAR_TYPE . ASSIGN VARIABLE_VALUE
    ASSIGN          shift and go to state 75


state 58

    (1) expression -> VARIABLE_NAME IS ARRAY OF VAR_TYPE . WITH L_SQUARE_BRACKETS value_list R_SQUARE_BRACKETS
    WITH            shift and go to state 76


state 59

    (31) expr -> expr / expr .
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    /               reduce using rule 31 (expr -> expr / expr .)
    *               reduce using rule 31 (expr -> expr / expr .)
    -               reduce using rule 31 (expr -> expr / expr .)
    +               reduce using rule 31 (expr -> expr / expr .)
    $end            reduce using rule 31 (expr -> expr / expr .)
    LE              reduce using rule 31 (expr -> expr / expr .)
    GE              reduce using rule 31 (expr -> expr / expr .)
    LT              reduce using rule 31 (expr -> expr / expr .)
    GT              reduce using rule 31 (expr -> expr / expr .)
    EQ              reduce using rule 31 (expr -> expr / expr .)
    RPAREN          reduce using rule 31 (expr -> expr / expr .)
    DO              reduce using rule 31 (expr -> expr / expr .)
    THEN            reduce using rule 31 (expr -> expr / expr .)
    ELSE            reduce using rule 31 (expr -> expr / expr .)


state 60

    (32) expr -> expr * expr .
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    /               reduce using rule 32 (expr -> expr * expr .)
    *               reduce using rule 32 (expr -> expr * expr .)
    -               reduce using rule 32 (expr -> expr * expr .)
    +               reduce using rule 32 (expr -> expr * expr .)
    $end            reduce using rule 32 (expr -> expr * expr .)
    LE              reduce using rule 32 (expr -> expr * expr .)
    GE              reduce using rule 32 (expr -> expr * expr .)
    LT              reduce using rule 32 (expr -> expr * expr .)
    GT              reduce using rule 32 (expr -> expr * expr .)
    EQ              reduce using rule 32 (expr -> expr * expr .)
    RPAREN          reduce using rule 32 (expr -> expr * expr .)
    DO              reduce using rule 32 (expr -> expr * expr .)
    THEN            reduce using rule 32 (expr -> expr * expr .)
    ELSE            reduce using rule 32 (expr -> expr * expr .)


state 61

    (33) expr -> expr - expr .
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    -               reduce using rule 33 (expr -> expr - expr .)
    +               reduce using rule 33 (expr -> expr - expr .)
    $end            reduce using rule 33 (expr -> expr - expr .)
    LE              reduce using rule 33 (expr -> expr - expr .)
    GE              reduce using rule 33 (expr -> expr - expr .)
    LT              reduce using rule 33 (expr -> expr - expr .)
    GT              reduce using rule 33 (expr -> expr - expr .)
    EQ              reduce using rule 33 (expr -> expr - expr .)
    RPAREN          reduce using rule 33 (expr -> expr - expr .)
    DO              reduce using rule 33 (expr -> expr - expr .)
    THEN            reduce using rule 33 (expr -> expr - expr .)
    ELSE            reduce using rule 33 (expr -> expr - expr .)
    /               shift and go to state 37
    *               shift and go to state 38


state 62

    (34) expr -> expr + expr .
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    -               reduce using rule 34 (expr -> expr + expr .)
    +               reduce using rule 34 (expr -> expr + expr .)
    $end            reduce using rule 34 (expr -> expr + expr .)
    LE              reduce using rule 34 (expr -> expr + expr .)
    GE              reduce using rule 34 (expr -> expr + expr .)
    LT              reduce using rule 34 (expr -> expr + expr .)
    GT              reduce using rule 34 (expr -> expr + expr .)
    EQ              reduce using rule 34 (expr -> expr + expr .)
    RPAREN          reduce using rule 34 (expr -> expr + expr .)
    DO              reduce using rule 34 (expr -> expr + expr .)
    THEN            reduce using rule 34 (expr -> expr + expr .)
    ELSE            reduce using rule 34 (expr -> expr + expr .)
    /               shift and go to state 37
    *               shift and go to state 38


state 63

    (29) expr -> LPAREN expr RPAREN .
    /               reduce using rule 29 (expr -> LPAREN expr RPAREN .)
    *               reduce using rule 29 (expr -> LPAREN expr RPAREN .)
    -               reduce using rule 29 (expr -> LPAREN expr RPAREN .)
    +               reduce using rule 29 (expr -> LPAREN expr RPAREN .)
    $end            reduce using rule 29 (expr -> LPAREN expr RPAREN .)
    LE              reduce using rule 29 (expr -> LPAREN expr RPAREN .)
    GE              reduce using rule 29 (expr -> LPAREN expr RPAREN .)
    LT              reduce using rule 29 (expr -> LPAREN expr RPAREN .)
    GT              reduce using rule 29 (expr -> LPAREN expr RPAREN .)
    EQ              reduce using rule 29 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 29 (expr -> LPAREN expr RPAREN .)
    DO              reduce using rule 29 (expr -> LPAREN expr RPAREN .)
    THEN            reduce using rule 29 (expr -> LPAREN expr RPAREN .)
    ELSE            reduce using rule 29 (expr -> LPAREN expr RPAREN .)


state 64

    (13) statement -> WHILE bool_op DO . statement
    (13) statement -> . WHILE bool_op DO statement
    (14) statement -> . IF bool_op THEN statement ELSE statement
    (15) statement -> . IF bool_op THEN statement
    (16) statement -> . bool_op
    (17) statement -> . expr
    (18) statement -> . VARIABLE_NAME L_SQUARE_BRACKETS VARIABLE_VALUE R_SQUARE_BRACKETS
    (19) statement -> . VARIABLE_NAME
    (20) statement -> . VARIABLES
    (21) statement -> . NAMES
    (22) bool_op -> . expr LE expr
    (23) bool_op -> . expr GE expr
    (24) bool_op -> . expr LT expr
    (25) bool_op -> . expr GT expr
    (26) bool_op -> . expr EQ expr
    (27) expr -> . VARIABLE_NAME
    (28) expr -> . VARIABLE_VALUE
    (29) expr -> . LPAREN expr RPAREN
    (30) expr -> . - expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    WHILE           shift and go to state 25
    IF              shift and go to state 27
    VARIABLE_NAME   shift and go to state 29
    VARIABLES       shift and go to state 30
    NAMES           shift and go to state 31
    VARIABLE_VALUE  shift and go to state 20
    LPAREN          shift and go to state 21
    -               shift and go to state 22

    bool_op                        shift and go to state 26
    statement                      shift and go to state 77
    expr                           shift and go to state 28

state 65

    (14) statement -> IF bool_op THEN . statement ELSE statement
    (15) statement -> IF bool_op THEN . statement
    (13) statement -> . WHILE bool_op DO statement
    (14) statement -> . IF bool_op THEN statement ELSE statement
    (15) statement -> . IF bool_op THEN statement
    (16) statement -> . bool_op
    (17) statement -> . expr
    (18) statement -> . VARIABLE_NAME L_SQUARE_BRACKETS VARIABLE_VALUE R_SQUARE_BRACKETS
    (19) statement -> . VARIABLE_NAME
    (20) statement -> . VARIABLES
    (21) statement -> . NAMES
    (22) bool_op -> . expr LE expr
    (23) bool_op -> . expr GE expr
    (24) bool_op -> . expr LT expr
    (25) bool_op -> . expr GT expr
    (26) bool_op -> . expr EQ expr
    (27) expr -> . VARIABLE_NAME
    (28) expr -> . VARIABLE_VALUE
    (29) expr -> . LPAREN expr RPAREN
    (30) expr -> . - expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    WHILE           shift and go to state 25
    IF              shift and go to state 27
    VARIABLE_NAME   shift and go to state 29
    VARIABLES       shift and go to state 30
    NAMES           shift and go to state 31
    VARIABLE_VALUE  shift and go to state 20
    LPAREN          shift and go to state 21
    -               shift and go to state 22

    bool_op                        shift and go to state 26
    statement                      shift and go to state 78
    expr                           shift and go to state 28

state 66

    (22) bool_op -> expr LE expr .
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    RPAREN          reduce using rule 22 (bool_op -> expr LE expr .)
    DO              reduce using rule 22 (bool_op -> expr LE expr .)
    THEN            reduce using rule 22 (bool_op -> expr LE expr .)
    ELSE            reduce using rule 22 (bool_op -> expr LE expr .)
    /               shift and go to state 37
    *               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40


state 67

    (23) bool_op -> expr GE expr .
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    RPAREN          reduce using rule 23 (bool_op -> expr GE expr .)
    DO              reduce using rule 23 (bool_op -> expr GE expr .)
    THEN            reduce using rule 23 (bool_op -> expr GE expr .)
    ELSE            reduce using rule 23 (bool_op -> expr GE expr .)
    /               shift and go to state 37
    *               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40


state 68

    (24) bool_op -> expr LT expr .
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    RPAREN          reduce using rule 24 (bool_op -> expr LT expr .)
    DO              reduce using rule 24 (bool_op -> expr LT expr .)
    THEN            reduce using rule 24 (bool_op -> expr LT expr .)
    ELSE            reduce using rule 24 (bool_op -> expr LT expr .)
    /               shift and go to state 37
    *               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40


state 69

    (25) bool_op -> expr GT expr .
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    RPAREN          reduce using rule 25 (bool_op -> expr GT expr .)
    DO              reduce using rule 25 (bool_op -> expr GT expr .)
    THEN            reduce using rule 25 (bool_op -> expr GT expr .)
    ELSE            reduce using rule 25 (bool_op -> expr GT expr .)
    /               shift and go to state 37
    *               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40


state 70

    (26) bool_op -> expr EQ expr .
    (31) expr -> expr . / expr
    (32) expr -> expr . * expr
    (33) expr -> expr . - expr
    (34) expr -> expr . + expr
    RPAREN          reduce using rule 26 (bool_op -> expr EQ expr .)
    DO              reduce using rule 26 (bool_op -> expr EQ expr .)
    THEN            reduce using rule 26 (bool_op -> expr EQ expr .)
    ELSE            reduce using rule 26 (bool_op -> expr EQ expr .)
    /               shift and go to state 37
    *               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40


state 71

    (18) statement -> VARIABLE_NAME L_SQUARE_BRACKETS VARIABLE_VALUE . R_SQUARE_BRACKETS
    R_SQUARE_BRACKETS shift and go to state 79


state 72

    (9) declaration -> CONSTANTS_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN . VARIABLE_VALUE
    VARIABLE_VALUE  shift and go to state 80


state 73

    (10) declaration -> CONSTANTS_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN . VARIABLE_VALUE
    VARIABLE_VALUE  shift and go to state 81


state 74

    (11) declaration -> VARIABLE_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN . VARIABLE_VALUE
    VARIABLE_VALUE  shift and go to state 82


state 75

    (12) declaration -> VARIABLE_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN . VARIABLE_VALUE
    VARIABLE_VALUE  shift and go to state 83


state 76

    (1) expression -> VARIABLE_NAME IS ARRAY OF VAR_TYPE WITH . L_SQUARE_BRACKETS value_list R_SQUARE_BRACKETS
    L_SQUARE_BRACKETS shift and go to state 84


state 77

    (13) statement -> WHILE bool_op DO statement .
    RPAREN          reduce using rule 13 (statement -> WHILE bool_op DO statement .)
    ELSE            reduce using rule 13 (statement -> WHILE bool_op DO statement .)


state 78

    (14) statement -> IF bool_op THEN statement . ELSE statement
    (15) statement -> IF bool_op THEN statement .
  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 85
    RPAREN          reduce using rule 15 (statement -> IF bool_op THEN statement .)


state 79

    (18) statement -> VARIABLE_NAME L_SQUARE_BRACKETS VARIABLE_VALUE R_SQUARE_BRACKETS .
    RPAREN          reduce using rule 18 (statement -> VARIABLE_NAME L_SQUARE_BRACKETS VARIABLE_VALUE R_SQUARE_BRACKETS .)
    ELSE            reduce using rule 18 (statement -> VARIABLE_NAME L_SQUARE_BRACKETS VARIABLE_VALUE R_SQUARE_BRACKETS .)


state 80

    (9) declaration -> CONSTANTS_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN VARIABLE_VALUE .
    CONSTANTS_PREFIX reduce using rule 9 (declaration -> CONSTANTS_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN VARIABLE_VALUE .)
    VARIABLE_PREFIX reduce using rule 9 (declaration -> CONSTANTS_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN VARIABLE_VALUE .)
    $end            reduce using rule 9 (declaration -> CONSTANTS_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN VARIABLE_VALUE .)


state 81

    (10) declaration -> CONSTANTS_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN VARIABLE_VALUE .
    CONSTANTS_PREFIX reduce using rule 10 (declaration -> CONSTANTS_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN VARIABLE_VALUE .)
    VARIABLE_PREFIX reduce using rule 10 (declaration -> CONSTANTS_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN VARIABLE_VALUE .)
    $end            reduce using rule 10 (declaration -> CONSTANTS_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN VARIABLE_VALUE .)


state 82

    (11) declaration -> VARIABLE_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN VARIABLE_VALUE .
    CONSTANTS_PREFIX reduce using rule 11 (declaration -> VARIABLE_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN VARIABLE_VALUE .)
    VARIABLE_PREFIX reduce using rule 11 (declaration -> VARIABLE_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN VARIABLE_VALUE .)
    $end            reduce using rule 11 (declaration -> VARIABLE_PREFIX VARIABLE_NAME COLON VAR_TYPE ASSIGN VARIABLE_VALUE .)


state 83

    (12) declaration -> VARIABLE_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN VARIABLE_VALUE .
    CONSTANTS_PREFIX reduce using rule 12 (declaration -> VARIABLE_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN VARIABLE_VALUE .)
    VARIABLE_PREFIX reduce using rule 12 (declaration -> VARIABLE_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN VARIABLE_VALUE .)
    $end            reduce using rule 12 (declaration -> VARIABLE_PREFIX VARIABLE_NAME IS VAR_TYPE ASSIGN VARIABLE_VALUE .)


state 84

    (1) expression -> VARIABLE_NAME IS ARRAY OF VAR_TYPE WITH L_SQUARE_BRACKETS . value_list R_SQUARE_BRACKETS
    (35) value_list -> . VARIABLE_VALUE
    (36) value_list -> . VARIABLE_VALUE COMMA value_list
    VARIABLE_VALUE  shift and go to state 87

    value_list                     shift and go to state 86

state 85

    (14) statement -> IF bool_op THEN statement ELSE . statement
    (13) statement -> . WHILE bool_op DO statement
    (14) statement -> . IF bool_op THEN statement ELSE statement
    (15) statement -> . IF bool_op THEN statement
    (16) statement -> . bool_op
    (17) statement -> . expr
    (18) statement -> . VARIABLE_NAME L_SQUARE_BRACKETS VARIABLE_VALUE R_SQUARE_BRACKETS
    (19) statement -> . VARIABLE_NAME
    (20) statement -> . VARIABLES
    (21) statement -> . NAMES
    (22) bool_op -> . expr LE expr
    (23) bool_op -> . expr GE expr
    (24) bool_op -> . expr LT expr
    (25) bool_op -> . expr GT expr
    (26) bool_op -> . expr EQ expr
    (27) expr -> . VARIABLE_NAME
    (28) expr -> . VARIABLE_VALUE
    (29) expr -> . LPAREN expr RPAREN
    (30) expr -> . - expr
    (31) expr -> . expr / expr
    (32) expr -> . expr * expr
    (33) expr -> . expr - expr
    (34) expr -> . expr + expr
    WHILE           shift and go to state 25
    IF              shift and go to state 27
    VARIABLE_NAME   shift and go to state 29
    VARIABLES       shift and go to state 30
    NAMES           shift and go to state 31
    VARIABLE_VALUE  shift and go to state 20
    LPAREN          shift and go to state 21
    -               shift and go to state 22

    bool_op                        shift and go to state 26
    statement                      shift and go to state 88
    expr                           shift and go to state 28

state 86

    (1) expression -> VARIABLE_NAME IS ARRAY OF VAR_TYPE WITH L_SQUARE_BRACKETS value_list . R_SQUARE_BRACKETS
    R_SQUARE_BRACKETS shift and go to state 89


state 87

    (35) value_list -> VARIABLE_VALUE .
    (36) value_list -> VARIABLE_VALUE . COMMA value_list
    R_SQUARE_BRACKETS reduce using rule 35 (value_list -> VARIABLE_VALUE .)
    COMMA           shift and go to state 90


state 88

    (14) statement -> IF bool_op THEN statement ELSE statement .
    RPAREN          reduce using rule 14 (statement -> IF bool_op THEN statement ELSE statement .)
    ELSE            reduce using rule 14 (statement -> IF bool_op THEN statement ELSE statement .)


state 89

    (1) expression -> VARIABLE_NAME IS ARRAY OF VAR_TYPE WITH L_SQUARE_BRACKETS value_list R_SQUARE_BRACKETS .
    $end            reduce using rule 1 (expression -> VARIABLE_NAME IS ARRAY OF VAR_TYPE WITH L_SQUARE_BRACKETS value_list R_SQUARE_BRACKETS .)


state 90

    (36) value_list -> VARIABLE_VALUE COMMA . value_list
    (35) value_list -> . VARIABLE_VALUE
    (36) value_list -> . VARIABLE_VALUE COMMA value_list
    VARIABLE_VALUE  shift and go to state 87

    value_list                     shift and go to state 91

state 91

    (36) value_list -> VARIABLE_VALUE COMMA value_list .
    R_SQUARE_BRACKETS reduce using rule 36 (value_list -> VARIABLE_VALUE COMMA value_list .)


Conflicts:

shift/reduce conflict for ELSE in state 78 resolved as shift
reduce/reduce conflict in state 29 resolved using rule statement -> VARIABLE_NAME
rejected rule (expr -> VARIABLE_NAME) in state 29